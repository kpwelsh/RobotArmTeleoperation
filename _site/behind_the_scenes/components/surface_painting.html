<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>Painting - Robot Teleoperation Platform</title> <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Painting | Robot Teleoperation Platform</title> <meta name="generator" content="Jekyll v3.9.0" /> <meta property="og:title" content="Painting" /> <meta property="og:locale" content="en_US" /> <link rel="canonical" href="http://localhost:4000/behind_the_scenes/components/surface_painting.html" /> <meta property="og:url" content="http://localhost:4000/behind_the_scenes/components/surface_painting.html" /> <meta property="og:site_name" content="Robot Teleoperation Platform" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Painting" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","headline":"Painting","url":"http://localhost:4000/behind_the_scenes/components/surface_painting.html"}</script> <!-- End Jekyll SEO tag --> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } }); </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"> </script> <script type="text/javascript" src="https://unpkg.com/mermaid@8.0.0-rc.8/dist/mermaid.min.js"> </script> <script> document.addEventListener('DOMContentLoaded', function() { mermaid.initialize({ theme: 'neutral' }); }, false); </script> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000/" class="site-title lh-tight"> Robot Teleoperation Platform </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="http://localhost:4000/" class="nav-list-link">Overview</a></li><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/behind_the_scenes/" class="nav-list-link">Behind the Scenes</a><ul class="nav-list "><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/behind_the_scenes/components/" class="nav-list-link">Components</a><ul class="nav-list"><li class="nav-list-item "> <a href="http://localhost:4000/behind_the_scenes/components/feedback_devices.html" class="nav-list-link">Feedback Devices</a> </li><li class="nav-list-item "> <a href="http://localhost:4000/behind_the_scenes/components/grasp_handling.html" class="nav-list-link">Grasp Handling</a> </li><li class="nav-list-item "> <a href="http://localhost:4000/behind_the_scenes/components/ik_plugins.html" class="nav-list-link">IK Plugins</a> </li><li class="nav-list-item "> <a href="http://localhost:4000/behind_the_scenes/components/input_devices.html" class="nav-list-link">Input Devices</a> </li><li class="nav-list-item active"> <a href="http://localhost:4000/behind_the_scenes/components/surface_painting.html" class="nav-list-link active">Painting</a> </li></ul></li><li class="nav-list-item "><a href="http://localhost:4000/behind_the_scenes/installation.html" class="nav-list-link">Installation</a></li><li class="nav-list-item "><a href="http://localhost:4000/behind_the_scenes/modified_components.html" class="nav-list-link">Modified Components</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="http://localhost:4000/task_models/" class="nav-list-link">Task Models</a><ul class="nav-list "><li class="nav-list-item "><a href="http://localhost:4000/task_models/robot_models.html" class="nav-list-link">Robot Arms</a></li><li class="nav-list-item "><a href="http://localhost:4000/task_models/tasks.html" class="nav-list-link">Tasks</a></li></ul></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Robot Teleoperation Platform" aria-label="Search Robot Teleoperation Platform" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/behind_the_scenes/">Behind the Scenes</a></li> <li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/behind_the_scenes/components/">Components</a></li> <li class="breadcrumb-nav-list-item"><span>Painting</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 id="surface-painting"> <a href="#surface-painting" class="anchor-heading" aria-labelledby="surface-painting"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Surface Painting </h1> <p>Writing directly to a texture based on spatial proximity is not something that is available in Unity by default. This is where the <code class="language-plaintext highlighter-rouge">Canvas</code> and <code class="language-plaintext highlighter-rouge">Marker</code> components come in.</p> <h2 id="canvas"> <a href="#canvas" class="anchor-heading" aria-labelledby="canvas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <code class="language-plaintext highlighter-rouge">Canvas</code> </h2> <p>The <code class="language-plaintext highlighter-rouge">DrawableMesh</code> component exposes two operations: <code class="language-plaintext highlighter-rouge">Clear</code>, which removes all current markings on the texture, and <code class="language-plaintext highlighter-rouge">Draw</code>, which adds new markings to the mesh. The <code class="language-plaintext highlighter-rouge">Draw</code> function takes a 3D capsule in world-space and compares it the mesh, adding the specified color over the texture wherever they intersect. This effect is achieved by maintaining 3 separate textures with a custom surface shader to layer the marker with the original texture, and a custom unlit shader that checks each pixel for intersection with the world-space capsule to determine whether or not it should be marked.</p> <h3 id="unity-shaders"> <a href="#unity-shaders" class="anchor-heading" aria-labelledby="unity-shaders"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Unity Shaders </h3> <p>A <a href="https://docs.unity3d.com/Manual/SL-VertexFragmentShaderExamples.html">“shader”</a> in Unity is simply a program that is compiled for and run on the GPU. A shader can be attached to a <a href="https://docs.unity3d.com/Manual/class-Material.html">material</a>, and is used to determine the color and lighting properties of a specific point on the surface of a mesh. The Unity shader infrastruture is set up to minimize the amount of work that is required of developers. For a simple surface shader, all that is needed is to create a function that maps the UV cooridnates to a struct of color properties. An example can be seen in the following section.</p> <h3 id="canvasshader"> <a href="#canvasshader" class="anchor-heading" aria-labelledby="canvasshader"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <code class="language-plaintext highlighter-rouge">Canvas.shader</code> </h3> <p>This custom shader is a simple surface shader that performs an alpha blending to layer the marker on top of the original mesh texture<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. The following is an excerpt from <code class="language-plaintext highlighter-rouge">Canvas.shader</code> with the boilerplate code elided:</p> <figure class="highlight"><pre><code class="language-hlsl" data-lang="hlsl"><span class="p">...</span>
<span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_Marker</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Input</span>
<span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="kt">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="k">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Albedo comes from a texture tinted by color</span>
    <span class="n">fixed4</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">)</span> <span class="o">*</span> <span class="n">_Color</span><span class="p">;</span>
    <span class="n">fixed4</span> <span class="n">marker_color</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_Marker</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="o">=</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
    <span class="c1">// Metallic and smoothness come from slider variables</span>
    <span class="n">o</span><span class="p">.</span><span class="n">Metallic</span> <span class="o">=</span> <span class="n">_Metallic</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">Smoothness</span> <span class="o">=</span> <span class="n">_Glossiness</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="o">=</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span></code></pre></figure> <p>In this example, the function <code class="language-plaintext highlighter-rouge">surf</code> takes a UV coordinate as an input, in the form of an <code class="language-plaintext highlighter-rouge">Input</code> struct.</p> <figure class="highlight"><pre><code class="language-hlsl" data-lang="hlsl"><span class="p">...</span>

<span class="k">struct</span> <span class="n">Input</span>
<span class="p">{</span>
    <span class="kt">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="kt">void</span> <span class="n">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span> <span class="p">...</span>
<span class="p">...</span></code></pre></figure> <p>It then looks up the color of the original texture as well as the marker texture to overlay, blends them together, and stores the result in the output parameter, <code class="language-plaintext highlighter-rouge">..., inout SurfaceOutputStandard o)</code>.</p> <figure class="highlight"><pre><code class="language-hlsl" data-lang="hlsl"><span class="p">...</span>

<span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_Marker</span><span class="p">;</span>
<span class="p">...</span>
    
    <span class="c1">// Albedo comes from a texture tinted by color</span>
    <span class="n">fixed4</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">)</span> <span class="o">*</span> <span class="n">_Color</span><span class="p">;</span>
    <span class="n">fixed4</span> <span class="n">marker_color</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_Marker</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="o">=</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
    <span class="c1">// Metallic and smoothness come from slider variables</span>
    <span class="n">o</span><span class="p">.</span><span class="n">Metallic</span> <span class="o">=</span> <span class="n">_Metallic</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">Smoothness</span> <span class="o">=</span> <span class="n">_Glossiness</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="o">=</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">marker_color</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
<span class="p">...</span></code></pre></figure> <p>The thread-global parameters <code class="language-plaintext highlighter-rouge">_MainTex</code> and <code class="language-plaintext highlighter-rouge">_Marker</code> are set by the Unity material object and the <code class="language-plaintext highlighter-rouge">DrawableMesh</code> component, respectively.</p> <figure class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="c1">// Start is called before the first frame update</span>
    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Read the texture attached to our gameObject.</span>
        <span class="n">Texture</span> <span class="n">mainTex</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;().</span><span class="n">material</span><span class="p">.</span><span class="n">mainTexture</span><span class="p">;</span>
        <span class="c1">// Create a new blank texture to hold the marker layer.</span>
        <span class="n">MarkerTex</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Texture2D</span><span class="p">(</span><span class="m">1024</span><span class="p">,</span> <span class="m">1024</span><span class="p">,</span> <span class="n">TextureFormat</span><span class="p">.</span><span class="n">RGBAFloat</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
        <span class="nf">fill</span><span class="p">(</span><span class="n">MarkerTex</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">));</span>
        <span class="p">...</span>
        <span class="c1">// Give the shader a pointer to the marker texture.</span>
        <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;().</span><span class="n">material</span><span class="p">.</span><span class="nf">SetTexture</span><span class="p">(</span><span class="s">"_Marker"</span><span class="p">,</span> <span class="n">MarkerTex</span><span class="p">);</span>
    <span class="p">}</span></code></pre></figure> <div class="table-wrapper"><table> <thead> <tr> <th style="text-align: center">Marker Texture</th> <th style="text-align: center">Main Texture</th> <th style="text-align: center">Rendered Result</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><img src="/assets/imgs/marker_overlay.png" alt="Marker Overlay" /></td> <td style="text-align: center"><img src="/assets/imgs/uw-madisonlogo.png" alt="UW Madison Logo" /></td> <td style="text-align: center"><img src="/assets/imgs/uw-madisonlogo-drawn.png" alt="UW Madison Logo" /></td> </tr> </tbody> </table></div> <h2 id="creating-the-marker-overlay"> <a href="#creating-the-marker-overlay" class="anchor-heading" aria-labelledby="creating-the-marker-overlay"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Creating the Marker Overlay </h2> <p>To determine whether or not a pixel should be marked, we need to generate a map from UV space to world-space<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. To do this, we are going to create a texture the same size as <code class="language-plaintext highlighter-rouge">_Marker</code> that will hold the 3D coordinates of each point in the RGB fields<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>. This approach requires rasterizing the mesh to the texture, using the UV coordinates of each vertex instead of its world coordinates. To avoid writing a custom CPU rasterization algorithm and make use of Unity’s render pipeline, we will opt to create a mesh in the unity world and take a picture of it using an orthographic camera.</p> <div class="table-wrapper"><table> <thead> <tr> <th style="text-align: center">World Space Cup Model</th> <th style="text-align: center">UV Unwrapped, Position Colored Mesh</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><img src="/assets/imgs/2022-04-25-14-32-17.png" alt="Cup Model" /></td> <td style="text-align: center"><img src="/assets/imgs/2022-04-25-14-32-55.png" alt="UV Rasterisation" /></td> </tr> </tbody> </table></div> <h3 id="rasterizeuv-function"> <a href="#rasterizeuv-function" class="anchor-heading" aria-labelledby="rasterizeuv-function"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <code class="language-plaintext highlighter-rouge">RasterizeUV</code> Function </h3> <p>To generate the colored mesh, we only need to loop through all of the vertices of the current mesh and make a new one with the vertex positions equal to the UV positions, and the color equal to the vertex position.</p> <p>We begin by looping through the vertices to create an axis aligned bounding box specified by the minimum corner and the size along each axis. For convenience later, we will store the <em>inverse</em> of the size in a vector as <code class="language-plaintext highlighter-rouge">scale</code>.</p> <figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">private</span> <span class="k">void</span> <span class="nf">RasterizeUV</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">mesh</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshFilter</span><span class="p">&gt;().</span><span class="n">mesh</span><span class="p">;</span>
    <span class="kt">float</span><span class="p">[]</span> <span class="n">min</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[]{</span><span class="kt">float</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">,</span> <span class="kt">float</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">,</span> <span class="kt">float</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">};</span>
    <span class="kt">float</span><span class="p">[]</span> <span class="n">max</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[]{</span><span class="kt">float</span><span class="p">.</span><span class="n">MinValue</span><span class="p">,</span> <span class="kt">float</span><span class="p">.</span><span class="n">MinValue</span><span class="p">,</span> <span class="kt">float</span><span class="p">.</span><span class="n">MinValue</span><span class="p">};</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="n">Vector3</span> <span class="n">v</span> <span class="k">in</span> <span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
            <span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="n">min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="n">max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Vector3</span> <span class="n">lower</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">min</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">min</span><span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="n">min</span><span class="p">[</span><span class="m">2</span><span class="p">]);</span>
    <span class="n">Vector3</span> <span class="n">scale</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span>
        <span class="m">1</span> <span class="p">/</span> <span class="p">(</span><span class="m">0.000001f</span> <span class="p">+</span> <span class="n">max</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">-</span> <span class="n">min</span><span class="p">[</span><span class="m">0</span><span class="p">]),</span> 
        <span class="m">1</span> <span class="p">/</span> <span class="p">(</span><span class="m">0.000001f</span> <span class="p">+</span> <span class="n">max</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">-</span> <span class="n">min</span><span class="p">[</span><span class="m">1</span><span class="p">]),</span> 
        <span class="m">1</span> <span class="p">/</span> <span class="p">(</span><span class="m">0.000001f</span> <span class="p">+</span> <span class="n">max</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">-</span> <span class="n">min</span><span class="p">[</span><span class="m">2</span><span class="p">])</span>
    <span class="p">);</span>
    <span class="p">...</span></code></pre></figure> <p>Next, we create a list of vertices from the UV coordinates. Here, mesh.uv stores the uv coordinates for each vertex<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>. We will choose <code class="language-plaintext highlighter-rouge">z = 0</code> for simplicity. We then loop again to set the color of our new vertices. The <a href="https://docs.unity3d.com/ScriptReference/Color.html">Color</a> struct stores rgba values as floats in [0, 1], so we transform our object coordinates to normalized coordinates using the bounding box we computed previously. Finally, we store a transformation matrix that maps normalized coordinates back to object coordinates to use in the shader later.</p> <figure class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="p">...</span>
    <span class="c1">// Set the positions</span>
    <span class="kt">float</span> <span class="n">aspectRatio</span> <span class="p">=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">MarkerTex</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="p">/</span> <span class="n">MarkerTex</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="n">Vector3</span><span class="p">[]</span> <span class="n">newVertices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector3</span><span class="p">[</span><span class="n">mesh</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">Length</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">newVertices</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">newVertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">mesh</span><span class="p">.</span><span class="n">uv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="p">*</span> <span class="n">aspectRatio</span><span class="p">,</span> <span class="n">mesh</span><span class="p">.</span><span class="n">uv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Set the colors</span>
    <span class="n">Color</span><span class="p">[]</span> <span class="n">colors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Color</span><span class="p">[</span><span class="n">newVertices</span><span class="p">.</span><span class="n">Length</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">colors</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
        <span class="n">Vector3</span> <span class="n">c</span> <span class="p">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">-</span> <span class="n">lower</span><span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="nf">Scale</span><span class="p">(</span><span class="n">scale</span><span class="p">);</span>
        <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">NormalizedToObj</span> <span class="p">=</span> <span class="n">Matrix4x4</span><span class="p">.</span><span class="nf">TRS</span><span class="p">(</span>
        <span class="n">lower</span><span class="p">,</span>
        <span class="n">Quaternion</span><span class="p">.</span><span class="n">identity</span><span class="p">,</span>
        <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">max</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">-</span> <span class="n">min</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">max</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">-</span> <span class="n">min</span><span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="n">max</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">-</span> <span class="n">min</span><span class="p">[</span><span class="m">2</span><span class="p">])</span>
    <span class="p">);</span>
    <span class="p">...</span></code></pre></figure> <p>Now that we have the vertices and colors correct, we just need to create and render our mesh. For this, we will create two gameobjects: a camera and the UV mesh. To ensure the color of the new mesh is not affected by lighting, we assign an unlit material (called <code class="language-plaintext highlighter-rouge">UVRaster</code> here) to it. To ensure this camera only sees our new mesh, we create a <a href="https://docs.unity3d.com/Manual/Layers.html">Layer</a> in the Unity Editor, assign it to our mesh, and tell the camera to only render that layer. Additionally, we will disable the camera script to prevent it from rendering every frame, since we only want to take a single picture, and assign a <a href="https://docs.unity3d.com/Manual/class-RenderTexture.html">Render Texture</a> as the target to render to.</p> <figure class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="p">...</span>
    <span class="n">GameObject</span> <span class="n">raster_obj</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">();</span>
    <span class="n">raster_obj</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">MeshFilter</span><span class="p">&gt;().</span><span class="n">mesh</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Mesh</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">uv_mesh</span> <span class="p">=</span> <span class="n">raster_obj</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshFilter</span><span class="p">&gt;().</span><span class="n">mesh</span><span class="p">;</span>

    <span class="n">uv_mesh</span><span class="p">.</span><span class="n">vertices</span> <span class="p">=</span> <span class="n">newVertices</span><span class="p">;</span>
    <span class="n">uv_mesh</span><span class="p">.</span><span class="n">colors</span> <span class="p">=</span> <span class="n">colors</span><span class="p">;</span>
    <span class="n">uv_mesh</span><span class="p">.</span><span class="n">triangles</span> <span class="p">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">triangles</span><span class="p">;</span>
    <span class="c1">// Mesh postprocessing</span>
    <span class="n">uv_mesh</span><span class="p">.</span><span class="nf">RecalculateNormals</span><span class="p">();</span>
    <span class="n">uv_mesh</span><span class="p">.</span><span class="nf">RecalculateTangents</span><span class="p">();</span>
    <span class="c1">// Create the game object and assign our </span>
    <span class="n">raster_obj</span><span class="p">.</span><span class="n">layer</span> <span class="p">=</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">NameToLayer</span><span class="p">(</span><span class="s">"UVRaster"</span><span class="p">);</span>
    <span class="n">raster_obj</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
    <span class="n">raster_obj</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;().</span><span class="n">material</span> <span class="p">=</span> <span class="n">UVRaster</span><span class="p">;</span>

    <span class="n">GameObject</span> <span class="n">cam_obj</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GameObject</span><span class="p">();</span>
    <span class="n">cam_obj</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">aspectRatio</span> <span class="p">/</span> <span class="m">2</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">);</span>
    <span class="n">cam_obj</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">Camera</span><span class="p">&gt;();</span>
    <span class="n">Camera</span> <span class="n">cam</span> <span class="p">=</span> <span class="n">cam_obj</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Camera</span><span class="p">&gt;();</span>
    <span class="n">cam</span><span class="p">.</span><span class="n">orthographic</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">cam</span><span class="p">.</span><span class="n">orthographicSize</span> <span class="p">=</span> <span class="m">0.5f</span><span class="p">;</span>
    <span class="n">cam</span><span class="p">.</span><span class="n">cullingMask</span> <span class="p">=</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">GetMask</span><span class="p">(</span><span class="s">"UVRaster"</span><span class="p">);</span>
    <span class="n">cam</span><span class="p">.</span><span class="n">enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">cam</span><span class="p">.</span><span class="n">targetTexture</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RenderTexture</span><span class="p">(</span><span class="n">MarkerTex</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">MarkerTex</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">ARGBFloat</span><span class="p">);</span>
    <span class="n">cam</span><span class="p">.</span><span class="n">clearFlags</span> <span class="p">=</span> <span class="n">CameraClearFlags</span><span class="p">.</span><span class="n">SolidColor</span><span class="p">;</span>
    <span class="n">cam</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">);</span>
    <span class="p">...</span></code></pre></figure> <p>Finally, we ask the camera to render to the texture. Since the Render Texture buffer data is stored on the GPU, we will create a new <code class="language-plaintext highlighter-rouge">Texture2D</code> and copy the data from the Render Texture into that. Then we can clean up by destroying both the camera and the UV mesh. We will also go ahead and set the <code class="language-plaintext highlighter-rouge">_UVPosition</code> parameter of our shader so it has it when it comes time to draw.</p> <figure class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="p">...</span>
    <span class="n">cam</span><span class="p">.</span><span class="nf">Render</span><span class="p">();</span>

    <span class="n">uvPositionTexture</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Texture2D</span><span class="p">(</span><span class="n">MarkerTex</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">MarkerTex</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">TextureFormat</span><span class="p">.</span><span class="n">RGBAFloat</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    
    <span class="n">RenderTexture</span><span class="p">.</span><span class="n">active</span> <span class="p">=</span> <span class="n">cam</span><span class="p">.</span><span class="n">targetTexture</span><span class="p">;</span>
    <span class="n">uvPositionTexture</span><span class="p">.</span><span class="nf">ReadPixels</span><span class="p">(</span><span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">MarkerTex</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">MarkerTex</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
    <span class="n">uvPositionTexture</span><span class="p">.</span><span class="nf">Apply</span><span class="p">();</span>
    <span class="n">RenderTexture</span><span class="p">.</span><span class="n">active</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
    
    <span class="n">DrawMat</span><span class="p">.</span><span class="nf">SetTexture</span><span class="p">(</span><span class="s">"_UVPosition"</span><span class="p">,</span> <span class="n">uvPositionTexture</span><span class="p">);</span>
    <span class="nf">Destroy</span><span class="p">(</span><span class="n">raster_obj</span><span class="p">);</span>
    <span class="nf">Destroy</span><span class="p">(</span><span class="n">cam_obj</span><span class="p">);</span>
    <span class="n">Initialized</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure> <h3 id="draw-function"> <a href="#draw-function" class="anchor-heading" aria-labelledby="draw-function"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <code class="language-plaintext highlighter-rouge">Draw</code> Function </h3> <p>Now that we have rasterized the UV mesh onto a texture, we have all of the peices we need to start drawing. The simplest thing to draw is a single point with a specified radius. However, we may not be calling this function with a super high frequency, it allows the caller to specify a value for <code class="language-plaintext highlighter-rouge">lastDrawPoint</code> to interpolate from. This amounts to intersecting the mesh with a cylinder specified by a line segment and a radius.</p> <figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">void</span> <span class="nf">Draw</span><span class="p">(</span><span class="n">Vector3</span> <span class="n">drawPoint</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span> 
                <span class="n">Color</span> <span class="n">drawColor</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">?</span> <span class="n">lastDrawPoint</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">Initialized</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="p">...</span></code></pre></figure> <p>The <code class="language-plaintext highlighter-rouge">DrawMatShader</code> shader is going to need several parameters, so we set those here. The radius, color, and line segment are taken as inputs from the caller, but we also will pass it a transformation matrix to transform the coordinates stored in the color values of the <code class="language-plaintext highlighter-rouge">_UVPosition</code> texture into world coordinates based on our object’s current pose.</p> <figure class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="p">...</span>
    <span class="n">DrawMat</span><span class="p">.</span><span class="nf">SetColor</span><span class="p">(</span><span class="s">"_DrawColor"</span><span class="p">,</span> <span class="n">drawColor</span><span class="p">);</span>
    <span class="n">DrawMat</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"_Radius"</span><span class="p">,</span> <span class="n">radius</span><span class="p">);</span>
    <span class="n">DrawMat</span><span class="p">.</span><span class="nf">SetMatrix</span><span class="p">(</span>
        <span class="s">"_NormalizedToWorld"</span><span class="p">,</span> 
        <span class="n">Matrix4x4</span><span class="p">.</span><span class="nf">TRS</span><span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">transform</span><span class="p">.</span><span class="n">rotation</span><span class="p">,</span> <span class="n">transform</span><span class="p">.</span><span class="n">localScale</span><span class="p">)</span>
        <span class="p">*</span> <span class="n">NormalizedToObj</span>
    <span class="p">);</span>
    <span class="n">DrawMat</span><span class="p">.</span><span class="nf">SetVector</span><span class="p">(</span><span class="s">"_DrawPoint"</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="n">drawPoint</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">drawPoint</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">drawPoint</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
    <span class="n">Vector3</span> <span class="n">last</span> <span class="p">=</span> <span class="n">lastDrawPoint</span><span class="p">.</span><span class="nf">GetValueOrDefault</span><span class="p">(</span><span class="n">drawPoint</span><span class="p">);</span>
    <span class="n">DrawMat</span><span class="p">.</span><span class="nf">SetVector</span><span class="p">(</span><span class="s">"_LastDrawPoint"</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Vector4</span><span class="p">(</span><span class="n">last</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">last</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">last</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="m">0</span><span class="p">));</span>
    <span class="p">...</span></code></pre></figure> <p>Then, the actual work is done by using Unity’s <a href="https://docs.unity3d.com/ScriptReference/Graphics.Blit.html">Blit</a> function to update our current marker overlay with any new marks. Then we can simply read the result back into the marker overlay texture, knowing that it will get rendered over our base material texture when a camera is looking at it.</p> <figure class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="p">...</span>
    <span class="n">RenderTexture</span> <span class="n">tmp</span> <span class="p">=</span> <span class="n">RenderTexture</span><span class="p">.</span><span class="nf">GetTemporary</span><span class="p">(</span><span class="n">MarkerTex</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">MarkerTex</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
    <span class="c1">// This first call to Blit stores the current marker overlay texture </span>
    <span class="c1">// into tmp</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">MarkerTex</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
    <span class="c1">// Then we invoke DrawMatShader on the uvPositionTexture with the parameters</span>
    <span class="c1">// we just set, and store the result in tmp as well.</span>
    <span class="c1">// By passing a material with our shader attached into Blit, it will run that</span>
    <span class="c1">// shader</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">uvPositionTexture</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">DrawMat</span><span class="p">);</span>

    <span class="n">RenderTexture</span><span class="p">.</span><span class="n">active</span> <span class="p">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">MarkerTex</span><span class="p">.</span><span class="nf">ReadPixels</span><span class="p">(</span><span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">MarkerTex</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">MarkerTex</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
    <span class="n">MarkerTex</span><span class="p">.</span><span class="nf">Apply</span><span class="p">();</span>
    <span class="n">RenderTexture</span><span class="p">.</span><span class="n">active</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

    <span class="n">RenderTexture</span><span class="p">.</span><span class="nf">ReleaseTemporary</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure> <h3 id="drawmatshader-fragment-shader"> <a href="#drawmatshader-fragment-shader" class="anchor-heading" aria-labelledby="drawmatshader-fragment-shader"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <code class="language-plaintext highlighter-rouge">DrawMatShader</code> Fragment Shader </h3> <p>The final piece of code here is the shader that checks each pixel in the marker texture to see if it should be marked or not. There are two things to call out here.</p> <p>Firstly, this shader uses an <a href="https://docs.unity3d.com/Manual/SL-Blend.html">alpha blend option</a> of</p> <figure class="highlight"><pre><code class="language-hlsl" data-lang="hlsl">    <span class="p">...</span>
    <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>
    <span class="p">...</span></code></pre></figure> <p>This just ensures that we don’t forget about old markings on the marker overlay when we Blit the new marks onto it.</p> <p>Secondly, the actual code that is being run for each pixel:</p> <figure class="highlight"><pre><code class="language-hlsl" data-lang="hlsl">    <span class="p">...</span>
    <span class="kt">float4</span> <span class="nf">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_Radius</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kt">float4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">r</span> <span class="o">=</span> <span class="n">_Radius</span> <span class="o">*</span> <span class="n">_Radius</span><span class="p">;</span>

        <span class="kt">float3</span> <span class="n">pos</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_UVPosition</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="nb">mul</span><span class="p">(</span><span class="n">_NormalizedToWorld</span><span class="p">,</span> <span class="kt">float4</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span> 

        <span class="kt">float3</span> <span class="n">a</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">_DrawPoint</span><span class="p">;</span>
        <span class="kt">float3</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">_LastDrawPoint</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">||</span> <span class="nb">dot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">_DrawColor</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">float3</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_LastDrawPoint</span> <span class="o">-</span> <span class="n">_DrawPoint</span><span class="p">;</span>
        <span class="n">float</span> <span class="n">l</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">));</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">l</span><span class="p">;</span>
        <span class="n">float</span> <span class="n">projectedDistance</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">projectedDistance</span> <span class="o">&gt;=</span> <span class="mi">0</span> 
            <span class="o">&amp;&amp;</span> <span class="n">projectedDistance</span> <span class="o">&lt;=</span> <span class="n">l</span>
            <span class="o">&amp;&amp;</span> <span class="nb">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">projectedDistance</span> <span class="o">*</span> <span class="n">projectedDistance</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
            
            <span class="k">return</span> <span class="n">_DrawColor</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kt">float4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span></code></pre></figure> <p>In this function, we extract the position from the texture color, transform it from normalized to world coordinates, and check the distance to the line segment to see if that pixel should be the marker color, or transparent.</p> <h2 id="marker"> <a href="#marker" class="anchor-heading" aria-labelledby="marker"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <code class="language-plaintext highlighter-rouge">Marker</code> </h2> <p>The <code class="language-plaintext highlighter-rouge">Marker</code> component serves only to trigger <code class="language-plaintext highlighter-rouge">Draw</code> calls to <code class="language-plaintext highlighter-rouge">DrawableMesh</code>es in the scene. To do this, it has a trigger collider that represents the marker “tip”. When it intersects with a <code class="language-plaintext highlighter-rouge">DrawableMesh</code>, it draws on the mesh at the closest point to the tip.</p> <figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">void</span> <span class="nf">OnTriggerStay</span><span class="p">(</span><span class="n">Collider</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DrawableMesh</span> <span class="n">dm</span> <span class="p">=</span> <span class="n">other</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">DrawableMesh</span><span class="p">&gt;();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dm</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">if</span> <span class="p">(!</span><span class="n">MeshDrawHistory</span><span class="p">.</span><span class="nf">ContainsKey</span><span class="p">(</span><span class="n">dm</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">MeshDrawHistory</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">Vector3</span> <span class="n">point</span> <span class="p">=</span> <span class="n">other</span><span class="p">.</span><span class="nf">ClosestPoint</span><span class="p">(</span><span class="n">Tip</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
        <span class="n">Vector3</span> <span class="n">last</span> <span class="p">=</span> <span class="n">MeshDrawHistory</span><span class="p">[</span><span class="n">dm</span><span class="p">].</span><span class="nf">GetValueOrDefault</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
        <span class="n">MeshDrawHistory</span><span class="p">[</span><span class="n">dm</span><span class="p">]</span> <span class="p">=</span> <span class="n">point</span><span class="p">;</span>
        <span class="n">dm</span><span class="p">.</span><span class="nf">Draw</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">Size</span><span class="p">,</span> <span class="n">DrawColor</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>This is also possible to do by adding a second material to the mesh and using Unity’s built in texture blending options. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>Shader code gets called for every pixel in the camera that is occupied by our object. To determine which things are visible, Unity already maps world-space coords to UV coords and you can receive it as an additional parameter in your shader function. So, it might be tempting to try to use the already known values. However, this proves difficult, since the resolution and whether or not the function is even called is determined by the camera position and parameters, which means things wouldn’t be drawn if you weren’t looking at them. Also, since you are not allowed to write global data in a shader thread, you can’t accumulate markings. So, we are out of luck and need to do it ourselves. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:3" role="doc-endnote"> <p>Overloading texture color data is a common way to do other things with shaders than render colors. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:4" role="doc-endnote"> <p>Unity <a href="https://docs.unity3d.com/ScriptReference/Mesh.html">Mesh</a>s can have multiple sets of UV coordinates. Loading uvs to the wrong channel when importing, or not explicitly generating them at all when making the mesh would cause this code to fail. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
